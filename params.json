{"name":"PHPFluent Filter","tagline":"A fluent filter library for PHP based on Zend\\Filter","body":"# PHPFluent\\Filter\r\n[![Build Status](https://secure.travis-ci.org/PHPFluent/Filter.png)](http://travis-ci.org/PHPFluent/Filter)\r\n[![Total Downloads](https://poser.pugx.org/phpfluent/filter/downloads.png)](https://packagist.org/packages/phpfluent/filter)\r\n[![License](https://poser.pugx.org/phpfluent/filter/license.png)](https://packagist.org/packages/phpfluent/filter)\r\n[![Latest Stable Version](https://poser.pugx.org/phpfluent/filter/v/stable.png)](https://packagist.org/packages/phpfluent/filter)\r\n[![Latest Unstable Version](https://poser.pugx.org/phpfluent/filter/v/unstable.png)](https://packagist.org/packages/phpfluent/filter)\r\n\r\nProvider a better API to handle Zend filters.\r\n\r\n## Installation\r\n\r\nPackage is available on [Packagist](https://packagist.org/packages/phpfluent/filter), you can install it\r\nusing [Composer](http://getcomposer.org).\r\n\r\n```bash\r\ncomposer require phpfluent/filter\r\n```\r\n\r\n## Usage\r\n\r\nThe static API was inspired on [Respect\\Validation](https://github.com/Respect/Validation).\r\n\r\n### Namespace Import\r\n\r\n_PHPFluent\\Filter_ is namespaced, but you can make your life easier by importing a single class into your context:\r\n\r\n```php\r\nuse PHPFluent\\Filter\\Builder as f;\r\n```\r\n\r\n### Calling a filter\r\n\r\n```php\r\nf::stringToUpper()->filter('phpfluent'); // returns: 'PHPFLUENT'\r\n```\r\n\r\n### Calling multiple filters\r\n\r\n```php\r\nf::stringToUpper()\r\n ->stringTrim()\r\n ->filter('filter    '); // returns 'PHPFLUENT'\r\n```\r\n\r\n### Calling native PHP functions\r\n\r\n```php\r\nf::json_encode(JSON_PRETTY_PRINT)\r\n ->filter(array('key' => 'value')); // returns: '{\"key\": \"value\"}'\r\n```\r\n\r\n### Non-static API\r\n\r\nYou also can simply create an instance of `PHPFluent\\Filter\\Builder`.\r\n\r\n```php\r\n$builder = new PHPFluent\\Filter\\Builder();\r\n$builder->ucfirst();\r\n$builder->str_pad(10, '-');\r\n$builder->filter('filter'); // returns: 'Filter----'\r\n```\r\n\r\n### Calling Builder class\r\n\r\n`PHPFluent\\Filter\\Builder` implements `__invoke()` method, so you can do like:\r\n\r\n```php\r\n$builder('filter'); // returns: 'Filter----'\r\n```\r\n\r\n### Custom filters\r\n\r\nYou can use your own Zend filters.\r\n\r\n```php\r\nf::myFilter();\r\n```\r\n\r\nFor that purpose we provide a way to add your own namespaces/prefixes:\r\n\r\n```php\r\nf::getDefaultFactory()->appendPrefix('My\\\\Filter\\\\Prefix');\r\n```\r\n\r\nSo, in the example above `v::myFilter()` will call `My\\Filter\\PrefixMyFilter`.\r\n\r\nYou can implement your own filter.\r\n\r\n```php\r\nuse PHPFluent\\Filter\\FilterInterface;\r\n\r\nclass UrlFilter implements FilterInterface\r\n{\r\n    public function filter($value)\r\n    {\r\n        return filter_var($value, FILTER_SANITIZE_URL);\r\n    }\r\n}\r\n```\r\n\r\n### Filter factory\r\n\r\nTo create the filters by its name we use our Factory; there are two ways to change the Factory to be used.\r\n\r\n#### Static calls\r\n\r\n```php\r\n$factory = new PHPFluent\\Filter\\Factory();\r\n$factory->prependPrefix('My\\\\Zend\\\\Filters\\\\');\r\n\r\nPHPFluent\\Filter\\Builder::setDefaultFactory($factory);\r\n```\r\n\r\nIn the example above the defined factory will be used for all static calls.\r\n\r\n#### Non-static calls\r\n\r\n```php\r\n$factory = new PHPFluent\\Filter\\Factory();\r\n$factory->prependPrefix('My\\\\Zend\\\\Filters\\\\');\r\n\r\n$builder = new PHPFluent\\Filter\\Builder($factory);\r\n```\r\n\r\nIn the example above the defined factory will be used only for the `$builder` instance variable.\r\n\r\nAs you could note, the factory instance if optional, so, when you did defined a factory for the builder object it will\r\nuse the default one, defined on `getDefaultFactory()`.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}